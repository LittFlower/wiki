`bash` 中：
1. 定义变量并为其赋值：`foo=bar`；
注意：*`foo = bar` 是错误的，因为解释器会理解为**调用程序 `foo` 并将 `=` 和 `bar` 作为参数**。*

2. 访问变量：`$foo`；

3. 用 `'` 定义的字符串为原义字符串，用 `"` 定义的字符串变量值会被替换；
4. bash 中使用了很多特殊的变量来表示参数、错误代码和相关变量。下面列举了其中一些变量，更完整的列表可以参考 [这里](https://www.tldp.org/LDP/abs/html/special-chars.html)。
- `$0` - 脚本名
- `$1` 到 `$9` - 脚本的参数。 `$1` 是第一个参数，依此类推。
- `$@` - 所有参数
- `$#` - 参数个数
- `$?` - 前一个命令的返回值
- `$$` - 当前脚本的进程识别码
- `!!` - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 `sudo !!`再尝试一次。
- `$_` - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 `Esc` 之后键入 `.` 来获取这个值。

5. 通过 `$(CMD)` 这样的方式来执行 `CMD` 这个命令时，它的输出结果会替换掉 `$(CMD)`；

6. 一个冷门的类似特性是 *进程替换*（*process substitution*），`<(CMD)` 会执行 `CMD` 并将结果输出到一个临时文件中，并将 `<(CMD)` 替换成临时文件名；

7. shell 的通配技术：
	* 通配符：当想要利用通配符进行匹配时，可以分别使用 `?` 和 `*` 来匹配一个或任意个字符。例如，对于文件`foo`, `foo1`, `foo2`, `foo10` 和 `bar`, `rm foo?`这条命令会删除`foo1` 和 `foo2` ，而`rm foo*` 则会删除除了`bar`之外的所有文件。
	* 花括号`{}`：当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。默认使用笛卡尔积。

8. 在 `shebang` 行中使用 [`env`](https://man7.org/linux/man-pages/man1/env.1.html) 命令是一种好的实践，它会利用环境变量中的程序来解析该脚本，提高了您的脚本的可移植性，例如，`#!/usr/bin/env python`；

9. [shellcheck](https://github.com/koalaman/shellcheck) 这样的工具可以帮助定位 sh/bash 脚本中的错误；

10. shell 函数和脚本的区别如下：
	- 函数只能与 shell 使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 `shebang` 是很重要的。
	- 函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。
	- 函数会在当前的 shell 环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用 [`export`](https://man7.org/linux/man-pages/man1/export.1p.html) 将环境变量导出，并将值传递给环境变量。
	- 与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell 脚本中往往也会包含它们自己的函数定义。


11. 使用 `tldr` 和 `man` 阅读手册；

12. `history` 可以查找历史 shell 命令，结合 `grep`/`rg` 使用；

13. `Ctrl+R` 可以配合 [fzf](https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r) 使用（使用 `/usr/share/fzf/key-bindings.zsh`）。`fzf` 是一个通用的模糊查找工具，它可以和很多命令一起使用；

14. `fasd` 可以提供频率和时效优先性的文件排序。

15. 使用 [xargs](https://man7.org/linux/man-pages/man1/xargs.1.html) 命令，它可以使用标准输入中的内容作为参数。 例如 ls | xargs rm 会删除当前目录中的所有文件。
