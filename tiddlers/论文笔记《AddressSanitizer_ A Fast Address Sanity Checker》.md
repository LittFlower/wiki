## 0x00. Abstract

对于 C 和 C++ 等编程语言来说，内存访问错误（包括缓冲区溢出和 use after free）仍然是一个严重问题。存在许多内存错误检测器，但大多数检测器要么速度慢，要么局限于有限的错误集，或者两者兼而有之。本文介绍了 AddressSanitizer，一种新的内存错误检测器。这个工具可以查找对堆、堆栈和全局变量的越界访问，以及 use after free。它采用专门的内存分配器和代码工具，足够简单，可以在任何编译器、二进制翻译系统甚至硬件中实现。AddressSanitizer 在不牺牲全面性的情况下实现了效率。它的平均速度仅为 73%，但它可以在错误发生时准确地检测到错误。它在 Chromium 浏览器中发现了 300 多个以前未知的错误，以及其他软件中的许多错误。

## 0x01. Introduction

AddressSanitizer 由两部分组成：**检测模块**和**运行时库**。**检测模块**修改代码以检查每次内存访问的*影子态 (shadow state)*，并在堆栈和全局对象周围创建*中毒红区*以检测向上或向下溢出。当前的实现基于 LLVM 编译器基础设施。**运行时库**替换了 `malloc`、`free` 和相关函数，在分配的堆区域周围创建*中毒红区*，延迟已释放堆区域的重用，并进行错误报告。

总的来说，这篇文章做了以下几件事：

- 说明了内存错误检测器可以利用*影子内存 shadow memory*的全面性，并且开销比传统方法低得多；
- 提出一种新颖的影子态编码方式，可实现紧凑的影子内存（高达 128-to-1），用于检测越界和 use-after-free 错误；
- 描述一个针对新实现的影子编码的专用内存分配器；
- 评估一个新的公开可用的工具，该工具可以有效地识别内存错误。

## 0x02. Related work

### 影子内存（shadow memory）

总的来说，按照对应用程序地址的处理可以把现有的工具分为两种：

- 通过直接缩放和偏移（其中完整应用程序地址空间映射到单个影子地址空间）；
- 通过涉及查表的额外转换来映射到影子地址空间。

直接缩放和偏移的例子有：

- TaintTrace
- LIFT

使用多级转换的例子有：

- Valgrind
- Dr.Memory

还有一些比较 trick 的工具：

- Umbra：兼顾布局灵活性和效率，使用可动态调整的缩放和偏移来直接映射地址而非使用查表的方式；
- BoundLess：利用 64 位寄存器的高 16 位来做到内存复用，但是在慢速路径下会退化；
- LBC：使用存储在应用程序内存中的特殊值执行快速路径的检查，并在慢速路径上依赖于两级影子内存。

### 实现

大部分内存检测工具都基于二进制文件，这些工具可以发现堆内存的越界和 UAF，还可以识别未初始化的读取，不过没办法识别堆栈和全局变量的越界错误，好消息是基本不会误报。例如：Valgrind，Dr.Memory，Discover，BoundsChecker 等等

而使用编译时检测的工具虽然可以检测堆栈对象的越界访问，但是无法检测所有的堆栈缓冲区溢出错误，而且可能误报，例如 Mudflap。

还有一些依赖于静态分析的检测工具，但是只支持 C 语言，例如 CClured，还有不开源的，例如 Insure++。

还有一些内存检测工具基于专门的内存分配器，使用 CPU 页面保护。每个分配的区域都被放置到一个专用页面（或一组页面）中。右侧（和/或左侧）的额外一页被分配并标记为不可访问。随后访问这些页面的页面错误将被报告为越界错误。这些工具会产生大量内存开销，并且在 malloc 密集型应用程序上可能会非常慢（因为每个 malloc 调用都需要至少一个系统调用）。此外，这些工具可能会遗漏某些类别的错误（例如，从 5 字节的内存区域的开头读取偏移量为 6 处的内存）。如果工具报告出错误，错误消息中会提供负责的说明。例如：Electric Fence、Duma、GuardMalloc 和 Page Heap 等工具。

其他一些工具依赖于对 `malloc` 的实现，包括 DieHarder（DieHard malloc 的后代）和 Dmalloc，有概率、有延迟发现内存错误。他们修改后的 `malloc` 函数在返回给用户的内存区域的周围添加了*中毒红区*，并用特殊的 magic 值填充新分配的内存。 free 函数还将 magic 值写入内存区域。

但是这种依赖于 magic number 的实现有一些问题，当 magic number 被读取时，这些工具没办法立刻知道这件事情，现有的 DieHard 只能靠比较程序输出来检测不正确的行为，所以这个报错是概率性的、延迟性的；同理，当 redzone 里填充的 magic number 被覆盖，稍后在空闲时检查这个 redzone 会发现这件事情，但是这些工具没办法知道越界写入或者 UAF 是什么时候发生的（（... ~~对于 malloc 密集的大型程序这就相当于给你报了个“你的程序有一个错误”~~

还有个问题，debug malloc 工具不处理堆栈变量

