ABI：Application Binary Interface.

# 什么是 Interface

Interface，接口，它是介于功能和功能消费者（用户）之间的一个“实体层”，它本身不做任何事情，只是调用后面的功能。

根据**用户**的不同，有不同类型的接口：

- 命令行界面（CLI）：接口是命令；
- 图形用户界面（GUI）：接口是按钮、窗口等；
- 应用程序接口（API）：接口是函数。

换一种说法，接口就是两个实体交互之间的一种约定。

# wikipedia 中对 ABI 定义

如下：

> ABI 包括以下细节：
> - 数据类型、大小和对齐方式；
> - 调用约定，它控制着函数参数的传递方式和返回值的获取方式；
> - 系统调用编号，以及应用程序应如何对操作系统进行系统调用。
>
> 其他 ABI 将以下细节标准化：
> - C++ 名称混淆;
> - 异常传递；
> - 同一平台编译器之间的调用约定，但不要求跨平台兼容性。


# ABI 与 API

ABI 与 API 非常相似，可以将其视为 API 的编译版本（或机器语言级别的 API）。

当你编写源代码时，你可以通过 API 访问库。代码编译完成后，应用程序通过 ABI 访问库中的二进制数据。ABI 定义了编译后的应用程序用于访问外部库的结构和方法（就像 API 一样），只是级别较低。

API 定义了向函数传递参数的顺序。ABI 定义了如何传递这些参数的机制（寄存器、堆栈等）。

API 定义了哪些函数属于库的一部分。ABI 定义了代码在库文件中的存储方式，以便任何使用库的程序都能找到并执行所需的函数。

对于使用外部库的应用程序来说，ABI 非常重要。

库中包含大量代码和其他资源，但程序必须知道如何在库文件中找到所需的内容。ABI 定义了库的内容在文件中的存储方式，程序使用 ABI 搜索文件并找到所需的内容。如果系统中的所有程序都符合相同的 ABI，那么任何程序都能使用任何库文件，无论它们是由谁创建的。Linux 和 Windows 使用不同的 ABI，因此 Windows 程序不知道如何访问为 Linux 编译的库。

# ABI 与文件格式

在 linux 平台上，二进制可执行文件是 ELF 文件格式，Windows 平台上则是 PE 格式。

以 linux 平台为例，ELF 文件格式定义了操作系统与应用程序之间的接口。当你告诉操作系统运行一个程序时，操作系统希望该程序以某种方式格式化，（例如）希望二进制文件的第一部分是一个 ELF 头文件，其中包含特定内存偏移的某些信息。

这就是应用程序向操作系统传递自身重要信息的方式。如果以非 ELF 二进制格式（如 a.out 或 PE）构建程序，那么期望使用 ELF 格式应用程序的操作系统将无法解释二进制文件或运行应用程序。这就是为什么 Windows 应用程序不能直接在 Linux 机器上运行（反之亦然），而必须重新编译或在某种可将二进制格式转换为另一种格式的仿真层中运行的一个重要原因。

# ABI 与 C++ 名称混淆

在库文件中查找函数时，通常是通过名称来查找的。

C++ 允许重载函数名称，因此仅凭名称不足以识别函数。C++ 编译器有自己的内部处理方法，称为**名称混淆**。

ABI 可以定义函数名称的标准编码方式，这样使用不同语言或编译器构建的程序就能找到所需的函数。

当你在 C++ 程序中使用 `extern "c"` 时，就是在指示编译器使用一种其他软件可以理解的标准化名称记录方式。

# ABI 与编译器

ABI 是一组决定调用习惯和结构布局的规则。Pascal 以与 C 应用程序相反的顺序在堆栈上传递参数，因此 Pascal 和 C 编译器不会编译为相同的 ABI。C 和 Pascal 编译器各自的标准隐含地确保了这一点。

C++ 编译器无法定义 "标准" 的名称混淆方法，因为没有标准方法。当 Windows 上存在相互竞争的 C++ 编译器时，C++ 编译器之间的名称混淆约定并不兼容。

# ABI 与 ISA

ABI 可以（部分）与 ISA 无关。某些方面（如调用约定）依赖于 ISA，而其他方面（如 C++ 类布局）则不依赖于 ISA。

此外，如果 64 位操作系统可以执行 32 位二进制文件，那么 32 位和 64 位代码的 ABI 也会不同。